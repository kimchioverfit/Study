# Build

소스코드부터 실행 파일 생성 까지의 전체 과정 

**Compile** + **Link** + etc

---

Build 의 구성 요소

1. Preprocessing
2. Compile
3. Assemble
4. Link

---

### Process  

```
[소스코드] → (전처리) → (컴파일) → [오브젝트파일]  
                        ↓  
          (링크 + 라이브러리 결합)  
                        ↓  
               [실행 파일 생성]
```


---



### 1. Preprocessing

C/C++ 에서 주로 진행됨. 
#include, #define 등의 전처리 지시문을 처리하는 과정 

### 2. Compile

.cpp 또는 .c파일을 obj파일로 변환 
이 단계에서 문법 오류 찾음 

### 3. Assemble

일부 언어만 해당, 현대 컴파일러는 자동으로 처리함 

### 4. Link

obj 파일과 lib, dll 등을 묶어 바이너리파일을 생성. 

Link 단계의 주요 작업 

| 기능           | 설명                                              |
| ------------ | ----------------------------------------------- |
| **심볼 결합**    | 여러 파일에 흩어진 함수, 전역 변수 등을 서로 연결                   |
| **주소 재배치**   | 코드와 데이터의 실제 메모리 주소를 계산 및 할당                     |
| **라이브러리 병합** | 정적 또는 동적 라이브러리에서 필요한 코드만 가져옴                    |
| **섹션 병합**    | 코드(.text), 데이터(.data), 초기화 안 된 데이터(.bss) 섹션을 통합 |
| **실행 헤더 생성** | 운영체제가 실행할 수 있도록 실행 포맷(PE/ELF) 구성                |

**Linking Process**

1. 입력 오브젝트파일 (.o) 로딩, 컴파일러가 생성한 기계어 파일 읽고 분석 
<br>
2. 심볼 테이블 분석 
   - 각 오브젝트 파일은 정의된 함수와 정의되지 않은 심볼을 가짐 
   - 링커는 이들을 모아서 **`글로벌 심볼 테이블`** 을 만들고, 
     - 정의된 심볼 매칭
     - 미정의된 참조를 올바른 정의에 연결
     - 중복 심볼이나 다중 정의는 링크 에러 발생 
<br>
3. 주소 결정 (Address binding)
   - 각 함수와 데이터의 실제 메모리 주소 또는 오프셋을 결정 
   - 여기서 실제 재배치(Relocation) 발생
<br>
4. 라이브러리 연결
   - 정적 라이브러리 (.a, .lib) : 필요한 부분을 복사하여 바이너리 파일에 포함.
   - 동적 라이브러리 (.so, .dll) : 실행 시 참조만 설정하고, 라이브러리 본체는 로딩 시 운영체제가 해결.
<br>
5. 출력 바이너리 생성 

---

### ⚙️ 정적 링크 vs 동적 링크

| 항목      | 정적 링크 (Static)           | 동적 링크 (Dynamic)                    |
| ------- | ------------------------ | ---------------------------------- |
| 수행 시점   | 컴파일/링크 시 포함              | 실행 시 운영체제가 로딩                      |
| 실행파일 크기 | 큼 (모든 코드 포함)             | 작음 (라이브러리 참조만)                     |
| 배포 용이성  | 좋음 (외부 필요 없음)            | 라이브러리 배포 필요                        |
| 성능      | 약간 빠름 (로드 불필요)           | 약간 느릴 수 있음 (동적 로딩 필요)              |
| 예       | `libc.a` 포함 → 실행 파일 내 삽입 | `libc.so` 참조 → 실행 시 `ld-linux`가 로딩 |
| 정보 은닉성          | ❌ 낮음 (코드 포함됨) | ✅ 높음 (API만 노출 가능) |
| 역공학 난이도         | ❌ 낮음          | ✅ 높음              |
| 라이선스 보호         | ❌ 어려움         | ✅ 가능 (DLL 인증 등)   |
| 보안 강화 전략 적용 가능성 | ❌ 제한적         | ✅ 자유롭게 가능         |
| 유지보수 및 교체       | ❌ 재빌드 필요      | ✅ DLL 교체만으로 가능    |


